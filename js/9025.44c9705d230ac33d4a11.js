"use strict";(self.webpackChunknew_bedford_framework=self.webpackChunknew_bedford_framework||[]).push([[9025],{9025:function(n,e,t){t.d(e,{A:function(){return Q}});t(94226);var o=t(45458),i=t(23029),r=t(92901),a=t(50388),c=t(53954),s=t(85501),v=t(64467),u=t(53222);var f=t(79853),l=t(84430),g=t(57064);function d(n,e,t){for(var o=e*n.itemSize,i=0;i<n.itemSize;i++)n.array[o+i]=t[i]}function y(n){var e=n.geometry,t=n.attributeName,o=n.itemSize,i=n.instanceCount,r=n.factory,a=new Float32Array(i*o),c=(0,l.A)(e,t,new g.A({array:a,itemSize:o,divisor:1}));if(r)for(var s=[],v=0;v<i;v++)r(s,v,i),d(c,v,s)}var m=t(94992),x=t(99076),h=t(45299),p=t(42512),z=function(n){function e(n){var t,o=n.geometry,i=n.material,r=n.offset,a=void 0===r?0:r,c=n.count,s=void 0===c?o.index.count:c,v=n.primcount,u=void 0===v?1:v;return(0,p.a)(this,e),(t=(0,p.d)(this,e,[{geometry:o,material:i,offset:a,count:s}])).primcount=u,t}return(0,p.c)(e,n),(0,p._)(e,[{key:"draw",value:function(n){n.drawElementsInstanced(this.mode,this.count,this.index.type,this.offset,this.primcount)}}])}(t(73127).A),P=t(80225),A=t(55322),_=t(58165),w=t(35349),b=t(22131),S=t(88731),I=t(91028),M=t(76949),T=t.n(M),C=t(94101),U=t.n(C),E=t(90121),k=t.n(E),D=t(16678),j=t.n(D),N=t(34949),G=t.n(N),L={identity:T(),scale:U(),translate:k(),rotateX:j(),rotateY:G()},F=t(32171),O=t(49852),R=t(75170),q=t(67934);function B(n,e,t){return e=(0,c.A)(e),(0,a.A)(n,Y()?Reflect.construct(e,t||[],(0,c.A)(n).constructor):e.apply(n,t))}function Y(){try{var n=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(n){}return(Y=function(){return!!n})()}var V=u.Ay.BLEND,Z=u.Ay.FUNC_ADD,X=u.Ay.SRC_ALPHA,H=u.Ay.ONE,J=u.Ay.DEPTH_TEST,K=1e5,Q=function(n){function e(n,t){var o;return(0,i.A)(this,e),o=B(this,e,[n,t]),(0,v.A)(o,"clearColor",[0,0,0,1]),(0,v.A)(o,"timer",new q.A),(0,v.A)(o,"speed",0),(0,v.A)(o,"distortionSpeed",0),(0,v.A)(o,"mixinArrays",(function(n){n.extensions.get("OES_element_index_uint"),function(n){!function(n,e,t){var o=n.extensions.get(e);for(var i in t)n.gl[t[i]]=o[i].bind(o)}(n,"ANGLE_instanced_arrays",{drawElementsInstancedANGLE:"drawElementsInstanced",drawArraysInstancedANGLE:"drawArraysInstanced",vertexAttribDivisorANGLE:"vertexAttribDivisor"})}(n)})),(0,v.A)(o,"createBokehGeometry",(function(){var n=K,e=function(n,e){return n+(e-n)*Math.random()},t=(0,f.A)({width:1,height:1});return y({geometry:t,instanceCount:n,attributeName:"aOffset",itemSize:3,factory:function(n){n[0]=e(-1,1),n[1]=e(-1,1),n[2]=e(-1,1)}}),y({geometry:t,instanceCount:n,attributeName:"aDelayDuration",itemSize:2,factory:function(n){n[0]=e(0,1),n[1]=e(.5,1)}}),y({geometry:t,instanceCount:n,attributeName:"aParticle",itemSize:4,factory:function(n){n[0]=e(.1,1),n[1]=e(.25,.75),n[2]=e(.25,.75),n[3]=e(0,1)}}),t})),o.isSupported?(o.createResources(),o.updateUniforms(),o.updateAutoUpdate(),o.refresh(),o.renderer.onContextCreate.add(o.mixinArrays),o.mixinArrays(o.renderer),o):(0,a.A)(o)}return(0,s.A)(e,n),(0,r.A)(e,[{key:"createResources",value:function(){this.camera=new m.A({fov:40,near:1,far:1e4}),this.camera.position=[0,0,100],(0,x.A)(this.camera),this.modelMatrix=L.identity([]),this.particles=(0,h.A)({DrawInfoClass:z,primcount:K,geometry:this.getGeometry({key:"bokeh-geometry",factory:this.createBokehGeometry}),uniforms:{uTime:0,uDistortionTime:0,uModelMatrix:this.modelMatrix,uViewMatrix:this.camera.viewMatrix,uProjectionMatrix:this.camera.projectionMatrix,uStart:[0,0,0],uEnd:[0,0,0]},program:this.getProgram({key:"bokeh-program",factory:function(){return new P.A({vert:'\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_3843310594(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_3843310594(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_3843310594(vec4 x)\n{\n  return mod289_3843310594(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_3843310594(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_3843310594(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3843310594(Pi0);\n  Pi1 = mod289_3843310594(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_3843310594(permute_3843310594(ix) + iy);\n  vec4 ixy0 = permute_3843310594(ixy + iz0);\n  vec4 ixy1 = permute_3843310594(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_3843310594(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_3843310594(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_3843310594(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aUv;\n\nattribute vec3 aOffset;\nattribute vec4 aParticle;\nattribute vec2 aDelayDuration;\n\nuniform float uTime;\nuniform float uDistortionTime;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec3 uStart;\nuniform vec3 uEnd;\nuniform float uSize;\nuniform float uSeed;\nuniform vec4 uPath;\nuniform float uOffset;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec4 vParticle;\n\nvoid main() {\n  float p = mod((uTime + aDelayDuration.x), aDelayDuration.y) / aDelayDuration.y;\n\n  vec3 pathPosition = mix(uStart, uEnd, p);\n\n  vec3 position = pathPosition;\n\n  float n1 = cnoise(vec3(p + uDistortionTime, uSeed, 0.0) * uPath.x);\n  float n2 = cnoise(vec3(p + uDistortionTime, uSeed, 0.0) * uPath.z);\n\n  position.y += n1 * uPath.y;\n  position.z += n2 * uPath.w;\n\n  float n3 = n2 * 0.5 + 0.3;\n\n  position += aOffset * n3 * uOffset;\n\n  float n = cnoise(position * 0.1);\n\n  position.z += n * 4.0;\n\n  position += aPosition * uSize * aParticle.x * n;\n\n  vUv = aUv;\n  vPosition = position;\n  vParticle = aParticle;\n\n  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(position, 1.0);\n}\n',frag:"\nuniform vec3 uColor1;\nuniform vec3 uColor2;\nuniform float uAlpha;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvarying vec4 vParticle;\n\nfloat circle(vec2 uv, vec2 blur, float r) {\n  vec2 dist = uv - vec2(0.5);\n\n  return 1.0 - smoothstep(r - (r * blur.x), r + (r * blur.y), dot(dist, dist) * 4.0);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid main() {\n  float depth = abs(map(vPosition.z, -160., 160., 0., 1.));\n  depth *= depth;\n\n  float radius = 0.5;\n  float innerBlur = vParticle.y + 0.5 * depth;\n  float outerBlur = vParticle.z + 0.5 * depth;\n  // float innerBlur = vParticle.y;\n  // float outerBlur = vParticle.z;\n  vec2 blur = vec2(innerBlur, outerBlur);\n\n  float a = circle(vUv, blur, radius);\n\n  // if (a < 0.1) {\n  //   discard;\n  // }\n\n  vec3 color = mix(uColor1, uColor2, vParticle.w);\n\n  gl_FragColor = vec4(color * a * vParticle.w * uAlpha, a * uAlpha);\n}\n"})}})}),this.lightModelMatrix=L.identity([]),this.light=(0,h.A)({DrawInfoClass:A.A,geometry:this.getGeometry({key:"bokeh-light-geometry",factory:function(){return(0,f.A)({normal:!1})}}),program:this.getProgram({key:"bokeh-light-program",factory:function(){return new P.A({vert:"\nattribute vec3 aPosition;\nattribute vec2 aUv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 position = aPosition;\n\n  vUv = aUv;\n\n  gl_Position = vec4(position, 1.0);\n}\n",frag:'\n//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_1828402684(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_1828402684(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_1828402684(vec4 x)\n{\n  return mod289_1828402684(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1828402684(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_1828402684(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_1828402684(Pi0);\n  Pi1 = mod289_1828402684(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_1828402684(permute_1828402684(ix) + iy);\n  vec4 ixy0 = permute_1828402684(ixy + iz0);\n  vec4 ixy1 = permute_1828402684(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_1828402684(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_1828402684(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_1828402684(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n#define PI 3.141592653589793\n\nuniform float uTime;\n\nuniform vec3 uColor;\nuniform float uIntensity;\nuniform float uAngle;\nuniform float uPosition;\n\nvarying vec2 vUv;\n\nconst highp float NOISE_GRANULARITY = 0.5/255.0;\n\nhighp float random(vec2 coords) {\n  return fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotate(vec2 uv,float amount){\n  float ca = cos(amount);\n  float sa = sin(amount);\n\n  return vec2(\n    uv.x * ca + uv.y * sa,\n    -uv.x * sa + uv.y * ca\n  );\n}\n\nvoid main() {\n  vec2 coord = vUv - vec2(0.5);\n  coord = rotate(coord, uAngle);\n  coord += vec2(0.5);\n\n  float n = cnoise(vec3(coord * vec2(8.0, 1.0), uTime * 0.25));\n  n = n * 0.5 + 0.5;\n  n *= vUv.y * vUv.y;\n\n  float c = 0.;\n  c = mix(0.0, 1.0, smoothstep(0.0, uPosition, vUv.x));\n  c = mix(c, 0.0, smoothstep(uPosition, 1.0, vUv.x));\n\n  n *= c * uIntensity;\n\n  n += mix(-NOISE_GRANULARITY, NOISE_GRANULARITY, random(vUv));\n\n  gl_FragColor = vec4(uColor, n);\n}\n'})}}),uniforms:{uTime:0,uModelMatrix:this.lightModelMatrix,uViewMatrix:this.camera.viewMatrix,uProjectionMatrix:this.camera.projectionMatrix}})}},{key:"updateAutoUpdate",value:function(){var n=this.props,e=n.speed,t=n.distortionSpeed;this.autoUpdate=!(0===e&&0===t)}},{key:"onUpdateProps",value:function(){this.updateUniforms(),this.updateAutoUpdate(),this.refresh()}},{key:"updateUniforms",value:function(){var n=this.props,e=n.color1,t=n.color2,i=n.backgroundColor,r=n.color3,a=n.size,c=n.count,s=n.speed,v=n.distortionSpeed,u=n.alpha,f=n.seed,l=n.complexityY,g=n.complexityZ,d=n.amplitudeY,y=n.amplitudeZ,m=n.offset,x=n.lightAngle,h=n.lightIntensity,p=n.lightX;this.clearColor=[].concat((0,o.A)((0,F.m)(i)),[1]),this.particles.primcount=0|(0,R.Tj)(c,0,100,0,K),Object.assign(this.particles.uniforms,{uColor1:(0,F.m)(e),uColor2:(0,F.m)(t),uSize:(0,R.Tj)(a,1,100,1,32),uAlpha:(0,R.Tj)(u,1,100,.01,1),uSeed:f,uPath:[(0,R.Tj)(l,0,100,0,6),(0,R.Tj)(d,0,100,0,100),(0,R.Tj)(g,0,100,0,6),(0,R.Tj)(y,0,100,0,100)],uOffset:(0,R.Tj)(m,0,100,1,60)}),Object.assign(this.light.uniforms,{uColor:(0,F.m)(r),uIntensity:(0,R.Tj)(h,0,100,0,1),uAngle:(0,R.Tj)(x,0,100,-.3*Math.PI,.3*Math.PI),uPosition:(0,R.Tj)(p,0,100,0,1)}),this.speed=(0,R.Tj)(s,-100,100,-.01,.01),this.distortionSpeed=(0,R.Tj)(v,-100,100,-.01,.01)}},{key:"update",value:function(n){var e=.001*this.timer.update(n);this.particles.uniforms.uTime+=e*this.speed,this.particles.uniforms.uDistortionTime+=e*this.distortionSpeed,this.light.uniforms.uTime+=e*this.speed}},{key:"render",value:function(){this.renderer.state.disable(J),this.renderer.state.enable(V),(0,_.A)(this.renderer.state,Z),(0,w.A)(this.renderer.state,X,H),(0,b.A)(this.renderer,this.particles),(0,b.A)(this.renderer,this.light),this.renderer.state.disable(V)}},{key:"onRefresh",value:function(){var n=this.canvas,e=n.width,t=n.height;this.camera.aspect=e/t;var o=(0,O.M)(this.camera,100),i=o.width,r=o.height,a=Math.max(i,r);this.particles.uniforms.uStart[0]=-.75*a,this.particles.uniforms.uEnd[0]=.75*a,(0,S.A)(this.camera)}}])}(I.A);(0,v.A)(Q,"defaultProps",{color1:"#d45071",color2:"#f8ba81",backgroundColor:"#28243e",color3:"#ffffff",size:1,count:0,speed:0,distortionSpeed:0,alpha:0,seed:0,complexityY:0,complexityZ:0,amplitudeY:0,amplitudeZ:0,offset:0,lightAngle:0,lightIntensity:0,lightX:0})},45458:function(n,e,t){t.d(e,{A:function(){return r}});var o=t(43145);var i=t(27800);function r(n){return function(n){if(Array.isArray(n))return(0,o.A)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||(0,i.A)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},14302:function(n,e,t){t.d(e,{F:function(){return r},hq:function(){return o},py:function(){return i}});var o="aPosition",i="aNormal",r="aUv"},79853:function(n,e,t){t.d(e,{A:function(){return s}});var o=t(14302),i=t(85579),r=t(84430),a=t(54790),c=t(57064);function s(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.width,t=void 0===e?2:e,s=n.height,v=void 0===s?2:s,u=n.widthSegments,f=void 0===u?1:u,l=n.heightSegments,g=void 0===l?1:l,d=n.position,y=void 0===d?o.hq:d,m=n.normal,x=void 0===m?o.py:m,h=n.uv,p=void 0===h?o.F:h,z=new i.A,P=[],A=[],_=[],w=[],b=0,S=Math.floor(f)||1,I=Math.floor(g)||1,M=S+1,T=I+1,C=t/S,U=v/I,E=.5*t,k=.5*v,D=0;D<T;D++)for(var j=D*U-k,N=0;N<M;N++){var G=N*C-E;P[3*b+0]=G,P[3*b+1]=-j,P[3*b+2]=0,A[3*b+0]=0,A[3*b+1]=0,A[3*b+2]=1,_[2*b]=N/S,_[2*b+1]=1-D/I,b++}for(var L=0;L<I;L++)for(var F=0;F<S;F++){var O=F+M*L,R=F+M*(L+1),q=F+1+M*(L+1),B=F+1+M*L;w.push(O,R,B),w.push(R,q,B)}return y&&(0,r.A)(z,y,new c.A({array:new Float32Array(P),itemSize:3})),x&&(0,r.A)(z,x,new c.A({array:new Float32Array(A),itemSize:3})),p&&(0,r.A)(z,p,new c.A({array:new Float32Array(_),itemSize:2})),(0,a.A)(z,new Uint16Array(w)),z}},58165:function(n,e,t){t.d(e,{A:function(){return i}});var o="blendEquation";function i(n,e,t){var i=void 0===t?"".concat(e):"".concat(e,"-").concat(t);n.get(o)!==i&&(void 0===t?n.gl.blendEquation(e):n.gl.blendEquationSeparate(e,t),n.set(o,i))}},35349:function(n,e,t){t.d(e,{A:function(){return i}});var o="blendFunc";function i(n,e,t,i,r){var a=void 0===i?"".concat(e,"-").concat(t):"".concat(e,"-").concat(t,"-").concat(i,"-").concat(r);n.get(o)!==a&&(void 0===i?n.gl.blendFunc(e,t):n.gl.blendFuncSeparate(e,t,i,r),n.set(o,a))}}}]);